.TH _PRINTF 3 "November 2025" "Custom printf Project"
.SH NAME
_printf \- custom formatted output function

.SH SYNOPSIS
.B #include "main.h"
.br
.B int _printf(const char *format, ...);

.SH DESCRIPTION
The
.B _printf()
function writes formatted output to stdout according to a format string that specifies how subsequent arguments are converted for output.
This custom implementation supports multiple conversion specifiers, flags, for efficient output.

.PP
The format string may contain ordinary characters (printed directly) and conversion specifiers, which are introduced by '%'.

.SH PROJECT FUNCTIONS
This section details every function implemented in the project, describing their specific roles, and logic.

.TP
.B int _printf(const char *format, ...)
This is the central entry point of the custom printing system. It initializes the variable argument list and iterates through the input format string character by character. When it encounters a percentage sign, it pauses standard printing to invoke the `handle_specifier` function; otherwise, it passes characters directly. The function is responsible for the overall flow control, and returning the accurate total count of characters printed to the standard output.

.TP
.B int handle_specifier(const char *format, int *i, va_list cart)
Serving as the parsing engine of the project, this function is called whenever a format specifier is detected. It systematically analyzes the string following the percentage sign to identify active flags, field width parameters, precision settings, and length modifiers. Once the parsing is complete, it matches the specifier character to the correct printing function. It manages the index pointer to skip processed characters and accumulates the return values from helper functions to track the total print count accurately.

.TP
.B int _putchar(char c)
This function acts as the fundamental atomic unit for character output across the entire project. Rather than writing directly to the standard output, it serves as a wrapper that delegates the character to `buffer_char`. This abstraction ensures that every single character generated by any part of the program—whether from a complex number conversion or a simple string—passes through the centralized buffering system. It consistently returns 1 to indicate success, simplifying the character counting logic in higher-level functions.

.TP
.B void flush(void)
This critical memory management function enforces the actual output of data. It checks the current buffer index to see if any characters are pending and, if so, executes a single `write` system call to send the entire accumulated block to the standard output (file descriptor 1). After the write operation completes, it resets the internal buffer index to zero. This mechanism effectively "cleans" the buffer, preparing it to accept new data and ensuring that no output is lost when the program terminates.

.TP
.B int buffer_char(char c)
Designed to optimize performance, this function manages the storage of characters into a static 1024-byte array. Before adding a new character, it checks if the buffer has reached its capacity; if the buffer is full, it automatically triggers the `flush` function to empty the content. Only then does it insert the new character into the array and increment the index. This approach significantly reduces the number of system calls, as data is written in chunks rather than byte-by-byte.

.TP
.B int print_string(char *s, int width, int precision, int left_justify)
This function handles the formatting and output of standard C strings. It first checks if the provided string pointer is NULL and substitutes it with "(null)" if necessary. It calculates the string's length and determines the amount of padding required based on the specified field width and precision. The function then orchestrates the printing loop, placing spaces either before or after the string content depending on the left-justification flag, ensuring the output aligns perfectly within the designated field width.

.TP
.B int print_int(va_list args, int flags, int length, int width, ...)
A robust handler for signed integers, this function manages the complexities of converting `int` arguments to printable text. It detects the sign of the number to handle negative values, applies length modifiers like 'l' (long) or 'h' (short), and processes flags for explicit plus signs or leading spaces. It calculates the necessary zero padding for precision and space padding for width, ensuring the number is formatted correctly before passing the raw digits to the underlying number printing helper functions.

.TP
.B int print_number(long n)
This is a recursive or iterative helper function designed to print a generic long integer. It breaks down the number into individual digits by repeatedly using modulo and division arithmetic. If the number is negative, it handles the minus sign and converts the value to unsigned to avoid overflow issues with `LONG_MIN`. The digits are then printed sequentially to the standard output via `_putchar`. This function is the core logic engine used by `print_int` to physically output the numeric characters.

.TP
.B int print_binary(unsigned int n)
This specialized function converts an unsigned integer into its binary representation (base 2). It utilizes a local buffer to store the remainder of the number when divided by 2, effectively constructing the binary string in reverse order. Once the conversion loop is complete, it iterates backward through the local buffer to print the binary digits '0' and '1' in the correct order. This allows the user to visualize the bitwise composition of the integer argument directly in the output.

.TP
.B int print_unsigned(va_list args, int flags, int length, int width, ...)
Similar to the integer handler, this function is dedicated to unsigned decimal numbers. It retrieves the argument as an `unsigned long` based on the length modifier and verifies that no negative sign is printed. It calculates the number of digits required and applies padding for width and precision specifications. By strictly treating the input as unsigned, it ensures that large positive values are not misinterpreted as negative numbers, providing accurate decimal representation for `size_t` or `unsigned int` types.

.TP
.B int print_octal(va_list args, int flags, int length, int width, ...)
This function converts unsigned integers into octal format (base 8). It handles the optional '#' flag, which forces a leading '0' to indicate an octal literal. The function calculates the necessary buffer space and iteratively converts the number using base-8 arithmetic. It also manages field width and precision, padding the output with zeros or spaces as defined by the format string. This is essential for systems programming tasks where octal representation of permissions or bitmasks is common.

.TP
.B int print_hex(va_list args, int uppercase, int flags, int length, ...)
This versatile function handles hexadecimal conversion (base 16) for both lowercase (`%x`) and uppercase (`%X`) specifiers. It accepts a flag to determine which set of alpha-numeric characters to use (a-f or A-F). It also supports the '#' flag, which prepends "0x" or "0X" to non-zero values. The function carefully formats the output with the correct padding and precision, making it a comprehensive tool for debugging memory addresses and binary data in a readable hex format.

.TP
.B int print_string_escaped(va_list args)
Designed for safe data visualization, this function prints strings while revealing non-printable characters. It iterates through the input string and checks if a character's ASCII value falls outside the standard printable range (less than 32 or greater than or equal to 127). If a non-printable character is found, it is replaced by its hexadecimal ASCII code in the format `\xHH`. This is particularly useful for debugging strings containing control characters or hidden formatting bytes.

.TP
.B int print_pointer(va_list args, int width, int left_justify)
This function formats and prints memory addresses stored in void pointers. It first casts the argument to an unsigned long to handle the address value. If the pointer is NULL, it prints "(nil)"; otherwise, it formats the address in hexadecimal with a strictly prepended "0x" prefix. The function also supports field width and alignment, allowing memory addresses to be printed neatly in columns, which is essential for logging and debugging memory layouts.

.TP
.B int print_rev(va_list args)
This custom utility function retrieves a string argument and prints it in reverse order. It first iterates through the string to calculate its total length (finding the null terminator). Once the length is established, it starts a loop from the last character back to the first, passing each character to `_putchar`. This provides a simple way to reverse text output directly within the print statement without modifying the original string in memory.

.TP
.B int print_rot13(va_list args)
This function implements the ROT13 substitution cipher for the input string. It iterates through each character of the string and checks if it is a letter. If it is, the function shifts the character by 13 places in the alphabet, wrapping around if necessary (e.g., 'a' becomes 'n', 'N' becomes 'A'). Non-alphabetic characters are printed unchanged. This provides a quick method for basic obfuscation or decoding directly through the formatted output system.

.SH ARCHITECTURE OVERVIEW
The implementation has a modular architecture:

.RS
.TP
.B Main _printf Function
Loops over the format string, detects specifiers, delegates to handlers, and manages the buffer.
.TP
.B handle_specifier
Processes each specifier, applies flags, and calls the relevant conversion function.
.TP
.B Buffer System
A fixed 1024-byte buffer accumulates characters for efficient output, flushed when full or at the end.
.RE

.SH FLOWCHART
The following flowchart illustrates the _printf execution flow in ASCII suitable for man page:

.nf
        +----------------------+
        |     _printf Start    |
        +----------+-----------+
                   |
                   v
        +----------+-----------+
        | Format string valid? |
        +----+---------+-------+
             |         |
            No        Yes
             |         |
             v         v
       +------------+   +------------------+
       | Return -1  |   | Initialize va_list |
       +------------+   +------------------+
                           |
                           v
                   +------------------+
                   | Loop over format[] |
                   +------------------+
                           |
                           v
                   +------------------+
                   | Is format[i] == '%' ? |
                   +---------+--------+
                             |
                   +---------+---------+
                   |                   |
                  No                  Yes
                   |                   |
                   v                   v
          _putchar(format[i])   handle_specifier()
                   |                   |
                   +---------+---------+
                             |
                             v
                     +---------------+
                     | Add char to buffer |
                     +---------------+
                             |
                     +-------+-------+
                     | Buffer full?  |
                     +----+----+----+
                          |    |
                         Yes   No
                          |    |
                          v    v
                        flush() |
                          |    |
                          +----+
                             |
                             v
                     +---------------+
                     | End of format? |
                     +-------+-------+
                             |
                    +--------+--------+
                    |                 |
                   No                Yes
                    |                 |
                    +-----------------+
                             |
                             v
                           flush()
                             |
                             v
                         va_end(cart)
                             |
                             v
                       Return total_count
.fi

.SH FLAGS
.RS
.TP
.B +
For signed numbers (%d, %i), prepends a plus sign for positive values.
.TP
.B (space)
For signed numbers, prepends a space if no sign is printed.
.TP
.B #
For octal (%o), prepends '0'.
For hexadecimal (%x, %X), prepends '0x' or '0X' for non-zero values.
.RE

.SH CONVERSION SPECIFIERS
Supported specifiers:

.RS
.TP
.B %c
Print a single character (int argument).
.TP
.B %s
Print a string. If NULL, prints "(null)".
.TP
.B %S
Print a string with non-printable characters as '\xHH'.
.TP
.B %%
Print a literal '%'.
.TP
.B %d, %i
Signed decimal integer.
.TP
.B %b
Unsigned integer in binary.
.TP
.B %u
Unsigned decimal integer.
.TP
.B %o
Unsigned integer in octal.
.TP
.B %x
Unsigned integer in hexadecimal (lowercase).
.TP
.B %X
Unsigned integer in hexadecimal (uppercase).
.TP
.B %p
Pointer address in hexadecimal, NULL prints "(nil)".
.RE

.SH BUFFER IMPLEMENTATION
.RS
.TP
.B Buffer Size
1024 characters fixed.
.TP
.B Buffer Strategy
Characters are added until full or end of format string.
.TP
.B Flush Mechanism
Writes buffer content to stdout in a single write call.
.TP
.B Performance
Reduces system calls for faster output.
.RE

.SH RETURN VALUE
Returns total number of characters printed (excluding null terminator).
Returns -1 on error:
.RS
.TP
.B - format is NULL
.TP
.B - lone '%' at end of string
.TP
.B - system-level write failure
.RE

.SH EXAMPLES
The following examples demonstrate usage:

.RS
.nf
#include "main.h"
#include <limits.h>

int main(void)
{
    _printf("Char: %c\n", 'A');
    _printf("String: %s\n", "Hello, World!");
    _printf("Percent: %%\n");
    _printf("Signed: %+d, Space: % d\n", 42, 42);
    _printf("Binary: %b\n", 98);
    _printf("Unsigned: %u\n", 4294967295U);
    _printf("Octal: %#o\n", 64);
    _printf("Hex lowercase: %#x, Hex uppercase: %#X\n", 255, 255);
    _printf("Pointer: %p, Null pointer: %p\n", main, NULL);
    _printf("Escaped string: %S\n", "Hello\x01World\x7F");
    _printf("Multiple specifiers: %c %s %d %u %o %x %X %%\n", 'Z', "Test", -123, 456, 789, 255, 255);
    _printf("Long string: %s\n", "This is a long string to test the buffer flush mechanism.");
    return 0;
}
.fi
.RE

.SH LIMITATIONS
.RS
.TP
.B - Field width, precision, and length modifiers are not supported.
.TP
.B - Floating point (%f, %e, %g) not supported.
.TP
.B - Wide characters and locale support not included.
.TP
.B - No format string attack protection.
.RE

.SH TESTING METHODOLOGY
.RS
.TP
.B Unit Tests
Test each conversion specifier individually.
.TP
.B Integration Tests
Multiple specifiers per format string.
.TP
.B Edge Cases
NULL strings, zero, negative numbers, UINT_MAX.
.TP
.B Buffer Tests
Strings exceeding 1024 characters to test flush.
.TP
.B Memory Tests
Use Valgrind for memory leaks and undefined behavior.
.RE

.SH PORTABILITY
.RS
.TP
.B Standards Compliance
C89/C90 with GNU89 extensions.
.TP
.B Platform Assumptions
32/64-bit two's complement, ASCII encoding.
.TP
.B Dependencies
Requires stdarg.h, unistd.h, string.h, stdlib.h.
.RE

.SH AUTHORS
Developed by rama and badr for educational purposes.

.SH COPYRIGHT
This manual page and code are part of the printf project. Redistribution is permitted under project guidelines.

.SH HISTORY
Developed as an educational project to understand printf internals, variable argument handling, buffer optimization, and system calls.
